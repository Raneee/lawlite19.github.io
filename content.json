[{"title":"Hexo+Github搭建自己的博客","date":"2017-04-10T14:49:15.000Z","path":"2017/04/10/Hexo-Github搭建自己的博客/","text":"","tags":[{"name":"Github","slug":"Github","permalink":"http://lawlite.me/tags/Github/"}]},{"title":"致火影","date":"2017-03-24T13:57:12.000Z","path":"2017/03/24/致火影/","text":"致火影 ——只要有树叶飞舞的地方，火就会燃烧。 昨天就知道火影动漫也完结了，但是没有马上去看，想抽个正式点的时间。 漫画是700集完结，当时动漫到700的时候就有个打算想写点东西记录一下，但是没有动手。今天准备看时还在思考，看完一些回忆涌上，果断提笔。 初三的暑假，当时是在补课，一位小伙伴有火影的光盘，当时就借来看看。记得每天最多能看几十集，当时光盘里面应该是有300集左右。 暑假结束，步入高一，当时并不知道有漫画（毕竟高一才有的QQ），还在军训，班级里面有同学买的关于火影的海报，那时漫画里讲到鼬双重间谍的身份，以及多么爱他的弟弟佐助。后来有了个诺亚舟学习机（当然现在还在），有时周末就去网吧下载火影动漫看。现在来说有的一集看了不止10遍，当然我周围的小伙伴也有一块看的。 高一结束分班，我后面一排的一位小伙伴也看火影，每次周日下午回校，他都和我讨论，当时讨论的还有死神（死神、柯南都有看，但火影是我唯一看的完整的动漫（不算死亡笔记这种比较短的动漫））。 大三的时候火影漫画700完结（700之后的5话是番外），当时写了一段话，但没有发出来。当动漫700之后几集的片尾曲唱到：さようなら（再见）的时候，些许感慨，之后看的时候的片头曲和片尾曲很少跳过。 还记得岸本齐史（AB大叔）有说过，刚开始画火影的时候他还没有结婚，就像鸣人一样希望得到别人的注意，后来结婚，漫画里的鸣人也渐渐的有了朋友。最后定格在鸣人雏田结婚。 16岁到24岁，谢谢鸣人，谢谢火影! ——思念你的人所在的地方就是你的归宿！ 2017年3月24日","tags":[{"name":"随笔","slug":"随笔","permalink":"http://lawlite.me/tags/随笔/"}]},{"title":"Python机器学习","date":"2017-01-08T15:01:58.000Z","path":"2017/01/08/Python机器学习/","text":"机器学习算法Python实现说明 github地址：https://github.com/lawlite19/MachineLearning_Python 因为里面的公式加载出现问题，这里只给出了目录，可以去github中查看目录 机器学习算法Python实现 一、线性回归 1、代价函数 2、梯度下降算法 3、均值归一化 4、最终运行结果 5、使用scikit-learn库中的线性模型实现 二、逻辑回归 1、代价函数 2、梯度 3、正则化 4、S型函数（即） 5、映射为多项式 6、使用的优化方法 7、运行结果 8、使用scikit-learn库中的逻辑回归模型实现 逻辑回归_手写数字识别_OneVsAll 1、随机显示100个数字 2、OneVsAll 3、手写数字识别 4、预测 5、运行结果 6、使用scikit-learn库中的逻辑回归模型实现 三、BP神经网络 1、神经网络model 2、代价函数 3、正则化 4、反向传播BP 5、BP可以求梯度的原因 6、梯度检查 7、权重的随机初始化 8、预测 9、输出结果 四、SVM支持向量机 1、代价函数 2、Large Margin 3、SVM Kernel（核函数） 4、使用中的模型代码 5、运行结果 五、K-Means聚类算法 1、聚类过程 2、目标函数 3、聚类中心的选择 4、聚类个数K的选择 5、应用——图片压缩 6、使用scikit-learn库中的线性模型实现聚类 7、运行结果 六、PCA主成分分析（降维） 1、用处 2、2D–&gt;1D，nD–&gt;kD 3、主成分分析PCA与线性回归的区别 4、PCA降维过程 5、数据恢复 6、主成分个数的选择（即要降的维度） 7、使用建议 8、运行结果 9、使用scikit-learn库中的PCA实现降维 七、异常检测 Anomaly Detection 1、高斯分布（正态分布） 2、异常检测算法 3、评价的好坏，以及的选取 4、选择使用什么样的feature（单元高斯分布） 5、多元高斯分布 6、单元和多元高斯分布特点 7、程序运行结果","tags":[{"name":"Python","slug":"Python","permalink":"http://lawlite.me/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://lawlite.me/tags/机器学习/"}]},{"title":"Python科学计算","date":"2016-11-09T14:25:43.000Z","path":"2016/11/09/Python科学计算/","text":"一、Numpy1、Numpy特征和导入 （1）用于多维数组的第三方Python包 （2）更接近于底层和硬件 (高效) （3）专注于科学计算 (方便) （4）导入包：import numpy as np 2、list转为数组 （1）a = np.array([0,1,2,3]) （2）输出为：[0 1 2 3] （3）数据类型：&lt;type &#39;numpy.ndarray&#39;&gt; 3、一维数组 （1）a = np.array([1,2,3,4])属性a.ndim–&gt;维度为1a.shape–&gt;形状，返回(4,)len(a)–&gt;长度，4 （2）访问数组a[1:5:2]下标1-5，下标关系+2 （3）逆序 a[::-1] 4、多维数组 （1）二维：a = np.array([[0,1,2,3],[1,2,3,4]])输出为： [[0 1 2 3] [1 2 3 4]]a.ndm –&gt;2a.shape –&gt;(2,4)–&gt;行数，列数len(a) –&gt;2–&gt;第一维大小 （2）三维：a = np.array([[[0],[1]],[[2],[4]]])a.shape–&gt;(2,2,1) 5、用函数创建数组 （1）np.arange() a = np.arange(0, 10)b = np.arange(10)c = np.arange(0,10,2)输出： [0 1 2 3 4 5 6 7 8 9][0 1 2 3 4 5 6 7 8 9][0 2 4 6 8] （2）np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)等距离产生num个数 （3）np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)以log函数取 6、常用数组 （1）a = np.ones((3,3))输出： [[ 1. 1. 1.][ 1. 1. 1.][ 1. 1. 1.]] （2）np.zeros((3,3)) （3）np.eye(2)单位矩阵 （4）np.diag([1,2,3],k=0)对角矩阵，k为对角线的偏移 7、随机数矩阵 （1）a = np.random.rand(4)输出：[ 0.99890402 0.41171695 0.40725671 0.42501804]范围在[0,1]之间 （2）a = np.random.randn(4) Gaussian函数， （3）生成100个0-m的随机数: [t for t in [np.random.randint(x-x, m) for x in range(100)]] 也可以12m_arr = np.arange(0,m) # 生成0-m-1np.random.shuffle(m_arr) # 打乱m_arr顺序 然后取前100个即可 8、查看数据类型 （1）a.dtype 9、数组复制 （1）共享内存123a = np.array([1,2,3,4,5])b = aprint np.may_share_memory(a,b) 输出：True说明使用的同一个存储区域，修改一个数组同时另外的也会修改 （2）不共享内存b = a.copy() 10、布尔型 （1）1234a = np.random.random_integers(0,20,5)print aprint a%3==0print a[a % 3 == 0] 输出： [14 3 6 15 4] [False True True True False] [ 3 6 15] 11、中间数、平均值 （1）中间数np.median(a) （2）平均值np.mean(a), 若是矩阵，不指定axis默认求所有元素的均值 axis=0,求列的均值 axis=1，求行的均值 12、矩阵操作 （1）乘积np.dot(a,b)123a = np.array([[1,2,3],[2,3,4]])b = np.array([[1,2],[2,3],[2,2]])print np.dot(a,b) 或者使用np.matrix()生成矩阵，相乘需要满足矩阵相乘的条件 （2）内积np.inner(a,b)行相乘 （3）逆矩阵np.linalg.inv(a) （4）列的最大值np.max(a[:,0])–&gt;返回第一列的最大值 （5）每列的和np.sum(a,0) （6）每行的平均数np.mean(a,1) （7）求交集p.intersect1d(a,b)，返回一维数组 （8）转置：np.transpose(a) （9）两个矩阵对应对应元素相乘（点乘）：a*b 13、文件操作 （1）保存：tofile()123a = np.arange(10)a.shape=2,5a.tofile(&quot;test.bin&quot;) 读取：（需要注意指定保存的数据类型）12a = np.fromfile(&quot;test.bin&quot;,dtype=np.int32)print a （2）保存：np.save(&quot;test&quot;,a)–&gt;会保存成test.npy文件读取：a = np.load(&quot;test&quot;) 14、组合两个数组 （1）垂直组合 1234a = np.array([1,2,3])b = np.array([[1,2,3],[4,5,6]])c = np.vstack((b,a)) （2）水平组合 1234a = np.array([[1,2],[3,4]])b = np.array([[1,2,3],[4,5,6]])c = np.hstack((a,b)) 15、读声音Wave文件 （1）wave 1234567891011121314151617181920212223242526272829import wavefrom matplotlib import pyplot as pltimport numpy as np# 打开WAV文档f = wave.open(r&quot;c:\\WINDOWS\\Media\\ding.wav&quot;, &quot;rb&quot;)# 读取格式信息# (nchannels, sampwidth, framerate, nframes, comptype, compname)params = f.getparams()nchannels, sampwidth, framerate, nframes = params[:4]# 读取波形数据str_data = f.readframes(nframes)f.close()#将波形数据转换为数组wave_data = np.fromstring(str_data, dtype=np.short)wave_data.shape = -1, 2wave_data = wave_data.Ttime = np.arange(0, nframes) * (1.0 / framerate)# 绘制波形plt.subplot(211) plt.plot(time, wave_data[0])plt.subplot(212) plt.plot(time, wave_data[1], c=&quot;g&quot;)plt.xlabel(&quot;time (seconds)&quot;)plt.show() 16、where （1）找到y数组中=1的位置：np.where(y==1) 17、np.ravel(y) 将二维的转化为一维的，eg:(5000,1)--&gt;(5000,) 18、ndarray.flat函数 将数据展开对应的数组，可以进行访问 应用：0/1映射123456def dense_to_one_hot(label_dense,num_classes): num_labels = label_dense.shape[0] index_offset = np.arange(num_labels)*num_classes labels_one_hot = numpy.zeros((num_labels, num_classes)) labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1 return labels_one_hot 19、数组访问 X = np.array([[1,2],[3,4]]) X[0:1]和X[0:1,:]等价，都是系那是第一行数据 20、np.c_() 按照第二维度，即列拼接数据 np.c_[np.array([[1,2,3]]), 0, 0, np.array([[4,5,6]])]输出：array([[1, 2, 3, 0, 0, 4, 5, 6]]) 两个列表list拼接，长度要一致 np.c_[[1,2,3],[2,3,4]] np.c_[range(1,5),range(2,6)] 二、Matplotlib1、关于pyplot （1）matplotlib的pyplot子库提供了和matlab类似的绘图API，方便用户快速绘制2D图表。 （2）导入包：from matplotlib import pyplot as plt 2、绘图基础 （1）sin和cos 1234567x = np.linspace(-np.pi, np.pi,256,endpoint=True)C,S = np.cos(x),np.sin(x)plt.plot(x,C)plt.plot(x,S)plt.xlabel(&quot;x&quot;)plt.ylabel(&quot;y&quot;)plt.show() （2）指定绘图的大小 plt.figure(figsize=(8,6), dpi=80) （3）指定线的颜色、粗细和类型 plt.plot(x,C,color=”blue”,linewidth=2.0,linestyle=”-“,label=”cos”) 蓝色、宽度、连续、label（使用legend会显示这个label） （4）指定x坐标轴范围 plt.xlim(-4.0,4.0) （5）设置y抽刻度间隔plt.yticks(np.linspace(-1, 1, 15, endpoint=True)) （6）显示图例 plt.legend(loc=”upper left”) 显示在左上方 （7）一个figure上画多个图subplot方式 plt.subplot(1, 2, 1) plt.subplot(1, 2, 2) 例如：plt.subplot(m, n, p) 代表图共有的m行，n列，第p个图 p是指第几个图，横向数 上面代表有一行，两个图 [更详细解释]：231,232,233表示第一行的1,2,3个位置，接着的223表示把整个矩形分成4分，所以第3个位置就是第二行的第一个位置，但是相比第一行占了1.5列（每次subplot划分都是整个图重新划分） （8）一个figure上画多个图，axes方式 plt.axes([.1, .1, .8, .8]) plt.axes([.2, .2, .3, .3]) （9）填充 plt.fill_between(x, y1, y2=0, where=None, interpolate=False, step=None, hold=None, data=None) eg: 12plt.fill_between(X, 1, C+1, C+1&gt;1,color=&quot;red&quot;)plt.fill_between(X, 1, C+1, C+1&lt;1,color=&quot;blue&quot;) 3、散点图 （1） plt.scatter(X,Y) 4、条形图 （1） plt.bar(X, Y, facecolor=&quot;red&quot;, edgecolor=&quot;blue&quot; ) 填充颜色为facecolor,边界颜色为edgecolor 5、等高线图 （1）只显示等高线contour （2）显示表面contourf （3）注意三维图要用到meshgrid转化为网格12345678910111213def f(x,y): return (1 - x / 2 + x**5 + y**3) * np.exp(-x**2 -y**2)n = 256x = np.linspace(-3,3,n)y = np.linspace(-3,3,n)X,Y = np.meshgrid(x,y)plt.contourf(X,Y,f(X,Y),alpha=.5)C = plt.contour(X,Y,f(X, Y),colors=&quot;black&quot;,linewidth=.5)plt.clabel(C)plt.show() 6、显示图片imshow （1）123456789def f(x,y):return (1 - x / 2 + x ** 5 + y ** 3 ) * np.exp(-x ** 2 - y ** 2)n = 10x = np.linspace(-3, 3, 3.5 * n)y = np.linspace(-3, 3, 3.0 * n)X, Y = np.meshgrid(x, y)z = f(X,Y)plt.imshow(z)plt.show() 7、饼图pie （1）传入一个序列12345plt.figure(figsize=(8,8))n = 20Z = np.arange(10)plt.pie(Z)plt.show() 8、三维表面图* （1）需要导入包：from mpl_toolkits.mplot3d import Axes3D （2）1234567891011fig = plt.figure()ax = Axes3D(fig)X = np.arange(-4, 4, 0.25)Y = np.arange(-4, 4, 0.25)X, Y = np.meshgrid(X, Y)R = np.sqrt(X ** 2 + Y ** 2)Z = np.sin(R)ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.cm.hot)ax.contourf(X, Y, Z, zdir=&apos;z&apos;, offset=-2, cmap=plt.cm.hot)ax.set_zlim(-2, 2)plt.show() 9、legend显示问题 （1）12345p1, = plt.plot(np.ravel(X[pos,0]),np.ravel(X[pos,1]),&apos;ro&apos;,markersize=8)p2, = plt.plot(np.ravel(X[neg,0]),np.ravel(X[neg,1]),&apos;g^&apos;,markersize=8)plt.xlabel(&quot;X1&quot;)plt.ylabel(&quot;X2&quot;)plt.legend([p1,p2],[&quot;y==1&quot;,&quot;y==0&quot;]) 注意 p1后要加上,逗号，里面的数据要是一维的，使用np.ravel()转化一下 10、显示网格 （1）plt.grid(True, linestyle = &quot;-.&quot;, color = &quot;b&quot;, linewidth = &quot;1&quot;) 11、显示正方形的坐标区域 （1）plt.axis(&#39;square&#39;) 三、Scipy1、 Scipy特征 （1）内置了图像处理， 优化，统计等等相关问题的子模块 （2）scipy 是Python科学计算环境的核心。 它被设计为利用 numpy 数组进行高效的运行。从这个角度来讲，scipy和numpy是密不可分的。 2、文件操作io （1）导包：from scipy import io as spio （2）保存mat格式文件 spio.savemat(&quot;test.mat&quot;, {&#39;a&#39;:a}) （3）加载mat文件 data = spio.loadmat(&quot;test.mat&quot;) 访问值：data[‘a’]–&gt;相当于map （4）读取图片文件导包：from scipy import misc读取：data = misc.imread(&quot;123.png&quot;)[注1]：与matplotlib中plt.imread(&#39;fname.png&#39;)类似[注2]：执行misc.imread时可能提醒不存在这个模块，那就安装pillow的包 3、线性代数操作linalg （1）求行列式det res = linalg.det(a) （2）求逆矩阵inv res = linalg.inv(a) 若是矩阵不可逆，则会抛异常LinAlgError: singular matrix （3）奇异值分解svd u,s,v = linalg.svd(a) [注1]：s为a的特征值（一维），降序排列， [注2]：a = u*s*v’（需要将s转换一下才能相乘）12t = np.diag(s)print u.dot(t).dot(v) 4、梯度下降优化算法 （1）fmin_bfgs 1234def f(x): return x**2-2*xinitial_x = 0optimize.fmin_bfgs(f,initial_x) [注]：initial_x为初始点（此方法可能会得到局部最小值） （2）fmin()、fmin_cg等等方法 5、拟合（最小二乘法） （1）curve_fit123456789101112131415161718#产生数据def f(x): return x**2 + 10*np.sin(x)xdata = np.linspace(-10, 10, num=20)ydata = f(xdata)+np.random.randn(xdata.size)plt.scatter(xdata, ydata, linewidths=3.0, edgecolors=&quot;red&quot;)#plt.show()#拟合def f2(x,a,b): return a*x**2 + b*np.sin(x)guess = [2,2]params, params_covariance = optimize.curve_fit(f2, xdata, ydata, guess)#画出拟合的曲线x1 = np.linspace(-10,10,256)y1 = f2(x1,params[0],params[1])plt.plot(x1,y1)plt.show() 6、统计检验 （1）T-检验stats.ttest_ind123a = np.random.normal(0, 1, size=10)b = np.random.normal(1, 1, size=10)print stats.ttest_ind(a, b) 输出：(-2.6694785119868358, 0.015631342180817954)后面的是概率p: 两个过程相同的概率。如果其值接近1，那么两个过程几乎可以确定是相同的，如果其值接近0，那么它们很可能拥有不同的均值。 7、插值 （1）导入包：from scipy.interpolate import interp1d12345678910111213141516#产生一些数据x = np.linspace(0, 1, 10)y = np.sin(2 * np.pi * x)computed_time = np.linspace(0, 1, 50)#线性插值linear_interp = interp1d(x, y)linear_results = linear_interp(computed_time)#三次方插值cubic_interp = interp1d(x, y, kind=&apos;cubic&apos;)cubic_results = cubic_interp(computed_time)#作图plt.plot(x, y, &apos;o&apos;, ms=6, label=&apos;y&apos;)plt.plot(computed_time, linear_results, label=&apos;linear interp&apos;)plt.plot(computed_time, cubic_results, label=&apos;cubic interp&apos;)plt.legend()plt.show() 8、求解非线性方程组 （1）optimize中的fsolve1234567from scipy.optimize import fsolvedef func(x): x0,x1,x2 = x.tolist() return [5*x1-25,5*x0*x0-x1*x2,x2*x0-27]initial_x = [1,1,1]result = fsolve(func, initial_x)print result 四、pandas1、pandas特征与导入 （1）包含高级的数据结构和精巧的工具 （2）pandas建造在NumPy之上 （3）导入：12from pandas import Series, DataFrameimport pandas as pd 2、pandas数据结构（1）Series 一维的类似的数组对象 包含一个数组的数据（任何NumPy的数据类型）和一个与数组关联的索引 不指定索引：a = Series([1,2,3]) ，输出为 1230 11 22 3 包含属性a.index,a.values，对应索引和值 指定索引：a = Series([1,2,3],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])可以通过索引访问a[&#39;b&#39;] 判断某个索引是否存在：&#39;b&#39; in a 通过字典建立Series12dict = &#123;&apos;china&apos;:10,&apos;america&apos;:30,&apos;indian&apos;:20&#125;print Series(dict) 输出：1234america 30china 10indian 20dtype: int64 判断哪个索引值缺失：1234dict = &#123;&apos;china&apos;:10,&apos;america&apos;:30,&apos;indian&apos;:20&#125;state = [&apos;china&apos;,&apos;america&apos;,&apos;test&apos;]a = Series(dict,state)print a.isnull() 输出：（test索引没有对应值）1234china Falseamerica Falsetest Truedtype: bool 在算术运算中它会自动对齐不同索引的数据123a = Series([10,20],[&apos;china&apos;,&apos;test&apos;])b = Series([10,20],[&apos;test&apos;,&apos;china&apos;])print a+b 输出：123china 30test 30dtype: int64 指定Series对象的name和index的name属性1234a = Series([10,20],[&apos;china&apos;,&apos;test&apos;])a.index.name = &apos;state&apos;a.name = &apos;number&apos;print a 输出：1234statechina 10test 20Name: number, dtype: int64 （2）DataFrame Datarame表示一个表格，类似电子表格的数据结构 包含一个经过排序的列表集（按列名排序） 每一个都可以有不同的类型值（数字，字符串，布尔等等） DataFrame在内部把数据存储为一个二维数组的格式，因此你可以采用分层索引以表格格式来表示高维的数据 创建： 通过字典12345data = &#123;&apos;state&apos;: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;d&apos;], &apos;year&apos;: [2000, 2001, 2002, 2001, 2002], &apos;pop&apos;: [1.5, 1.7, 3.6, 2.4, 2.9]&#125;frame = DataFrame(data)print frame 输出：(按照列名排好序的[若是手动分配列名，会按照你设定的]，并且索引会自动分配) 123456 pop state year0 1.5 a 20001 1.7 b 20012 3.6 c 20023 2.4 d 20014 2.9 d 2002 访问 列：与Series一样，通过列名访问：frame[&#39;state&#39;]或者frame.state 行：ix 索引成员（field），frame.ix[2]，返回每一列的第3行数据 赋值：frame2[&#39;debt&#39;] = np.arange(5.)，若没有debt列名，则会新增一列 删除某一列：del frame2[&#39;eastern&#39;] 像Series一样， values 属性返回一个包含在DataFrame中的数据的二维ndarray 返回所有的列信息：frame.columns 转置：frame2.T （3）索引对象 pandas的索引对象用来保存坐标轴标签和其它元数据（如坐标轴名或名称） 索引对象是不可变的，因此不能由用户改变 创建index = pd.Index([1,2,3]) 常用操作 append–&gt;链接额外的索引对象，产生一个新的索引 diff –&gt;计算索引的差集 intersection –&gt;计算交集 union –&gt;计算并集 isin –&gt;计算出一个布尔数组表示每一个值是否包含在所传递的集合里 delete –&gt;计算删除位置i的元素的索引 drop –&gt;计算删除所传递的值后的索引 insert –&gt;计算在位置i插入元素后的索引 is_monotonic –&gt;返回True，如果每一个元素都比它前面的元素大或相等 is_unique –&gt;返回True，如果索引没有重复的值 unique –&gt;计算索引的唯一值数组 3、重新索引reindex（1）Series （1）重新排列 123a = Series([2,3,1],index=[&apos;b&apos;,&apos;a&apos;,&apos;c&apos;])b = a.reindex([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])print b （2）重新排列，没有的索引补充为0,b=a.reindex([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;],fill_value=0) （3）重建索引时对值进行内插或填充123a = Series([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],index=[0,2,4])b = a.reindex(range(6),method=&apos;ffill&apos;)print b 输出：12345670 a1 a2 b3 b4 c5 cdata_linkdtype: object method的参数ffill或pad—-&gt;前向（或进位）填充bfill或backfill—-&gt;后向（或进位）填充 （3）DataFrame 与Series一样，reindex index 还可以reindex column列，frame.reindex(columns=[&#39;a&#39;,&#39;b&#39;]) 4、从一个坐标轴删除条目（1）Series a.drop([&#39;a&#39;,&#39;b&#39;]) 删除a，b索引项（2）DataFrame 索引项的删除与Series一样 删除column—&gt;a.drop([&#39;one&#39;], axis=1) 删除column名为one的一列 5、索引，挑选和过滤（1）Series 可以通过index值或者整数值来访问数据，eg：对于a = Series(np.arange(4.), index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])，a[&#39;b&#39;]和a[1]是一样的 使用标签来切片和正常的Python切片并不一样，它会把结束点也包括在内12a = Series(np.arange(4.), index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])print a[&apos;b&apos;:&apos;c&apos;] 输出包含c索引对应的值 （2）DataFrame 显示前两行：a[:2] 布尔值访问：a[a[&#39;two&#39;]&gt;5] 索引字段 ix 的使用 index为2，column为’one’和’two’—&gt;a.ix[[2],[&#39;one&#39;,&#39;two&#39;]] index为2的一行：a.ix[2] 6、DataFrame和Series运算 （1）DataFrame每一行都减去一个Series12345a = pd.DataFrame(np.arange(16).reshape(4,4),index=[0,1,2,3],columns=[&apos;one&apos;, &apos;two&apos;,&apos;three&apos;,&apos;four&apos;])print ab = Series([0,1,2,3],index=[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;,&apos;four&apos;])print bprint a-b 输出：123456789101112131415 one two three four0 0 1 2 31 4 5 6 72 8 9 10 113 12 13 14 15one 0two 1three 2four 3dtype: int64 one two three four0 0 0 0 01 4 4 4 42 8 8 8 83 12 12 12 12 7、读取文件 （1）csv文件pd.read_csv(r&quot;data/train.csv&quot;)，返回的数据类型是DataFrame类型 8、查看DataFrame的信息 （1）train_data.describe()eg:123456789 PassengerId Survived Pclass Age SibSp \\count 891.000000 891.000000 891.000000 714.000000 891.000000 mean 446.000000 0.383838 2.308642 29.699118 0.523008 std 257.353842 0.486592 0.836071 14.526497 1.102743 min 1.000000 0.000000 1.000000 0.420000 0.000000 25% 223.500000 0.000000 2.000000 20.125000 0.000000 50% 446.000000 0.000000 3.000000 28.000000 0.000000 75% 668.500000 1.000000 3.000000 38.000000 1.000000 max 891.000000 1.000000 3.000000 80.000000 8.000000 9、定位到一列并替换 df.loc[df.Age.isnull(),&#39;Age&#39;] = 23 #&#39;Age&#39;列为空的内容补上数字23 10、将分类变量转化为指示变量get_dummies() 12s = pd.Series(list(&apos;abca&apos;))pd.get_dummies(s) 12345 a b c0 1 0 01 0 1 02 0 0 13 1 0 0 11、list和string互相转化 string转list 1234&gt;&gt;&gt; str = &apos;abcde&apos;&gt;&gt;&gt; list = list(str)&gt;&gt;&gt; list[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] list转string 123&gt;&gt;&gt; str_convert = &apos;,&apos;.join(list)&gt;&gt;&gt; str_convert&apos;a,b,c,d,e&apos; 12、删除原来的索引，重新从0-n索引 x = x.reset_index(drop=True) 13、apply函数 DataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None, ….. df.apply(numpy.sqrt) # returns DataFrame 等价==》df.apply(lambda x : numpy.sqrt(x))==&gt;使用更灵活 df.apply(numpy.sum, axis=0) # equiv to df.sum(0) df.apply(numpy.sum, axis=1) # equiv to df.sum(1) 13、re.search().group()函数 re.search(pattern, string, flags=0) group(num=0)函数返回匹配的字符，默认num=0,可以指定多个组号，例如group(0,1) 14、pandas.cut()函数 pandas.cut(x, bins, right=True, labels=None, retbins=False, precision=3, include_lowest=False) x为以为数组 bins可以是int值或者序列 若是int值就根据x分为bins个数的区间 若是序列就是自己指定的区间 right包含最右边的区间，默认为True labels 数组或者一个布尔值 若是数组，需要与对应bins的结果一致 若是布尔值False，返回bin中的一个值 eg:pd.cut(full[“FamilySize”], bins=[0,1,4,20], labels=[0,1,2]) 15、添加一行数据 定义空的dataframe: data_process = pd.DataFrame(columns=[&#39;route&#39;,&#39;date&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;10&#39;,&#39;11&#39;,&#39;12&#39;]) 定义一行新的数据，new = pd.DataFrame(columns=[&#39;route&#39;,&#39;date&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;10&#39;,&#39;11&#39;,&#39;12&#39;],index=[j]) 这里index可以随意设置，若是想指定就指定 添加：data_process = data_process.append(new, ignore_index=True)， 注意这里是data_process = data_process....... 五、scikit-learn1、手写数字识别（SVM）1234567891011121314151617181920212223242526272829from sklearn import datasetsfrom sklearn import svmimport numpy as npfrom matplotlib import pyplot as plt&apos;&apos;&apos;使用sciki-learn中的数据集，一般有data,target,DESCR等属性属性&apos;&apos;&apos;digits = datasets.load_digits() #加载scikit-learn中的数据集clf = svm.SVC(gamma=0.001,C=100) #使用支持向量机进行分类，gamma为核函数的系数clf.fit(digits.data[:-4],digits.target[:-4]) #将除最后4组的数据输入进行训练predict = clf.predict(digits.data[-4:]) #预测最后4组的数据，[-4:]表示最后4行所有数据，而[-4,:]表示倒数第4行数据print &quot;预测值为：&quot;,predictprint &quot;真实值：&quot;,digits.target[-4:]#显示最后四个图像plt.subplot(2,2,1)plt.imshow(digits.data[-4,:].reshape(8,8))plt.subplot(2,2,2)plt.imshow(digits.data[-3,:].reshape(8,8))plt.subplot(2,2,3)plt.imshow(digits.data[-2,:].reshape(8,8))plt.subplot(2,2,4)plt.imshow(digits.data[-1,:].reshape(8,8))plt.show() svm的参数参数解释： （1）C: 目标函数的惩罚系数C，用来平衡分类间隔margin和错分样本的，default C = 1.0； （2）kernel：参数选择有RBF, Linear, Poly, Sigmoid, 默认的是”RBF”; （3）degree：if you choose ‘Poly’ in param 2, this is effective, degree决定了多项式的最高次幂； （4）gamma：核函数的系数(‘Poly’, ‘RBF’ and ‘Sigmoid’), 默认是gamma = 1 / n_features; （5）coef0：核函数中的独立项，’RBF’ and ‘Poly’有效； （6）probablity: 可能性估计是否使用(true or false)； （7）shrinking：是否进行启发式； （8）tol（default = 1e - 3）: svm结束标准的精度; （9）cache_size: 制定训练所需要的内存（以MB为单位）； （10）class_weight:每个类所占据的权重，不同的类设置不同的惩罚参数C,缺省的话自适应； （11）verbose: 跟多线程有关，不大明白啥意思具体； （12）max_iter: 最大迭代次数，default = 1000， if max_iter = -1, no limited; （13）decision_function_shape ： ‘ovo’ 一对一, ‘ovr’ 多对多 or None 无, default=None （14）random_state ：用于概率估计的数据重排时的伪随机数生成器的种子。 2、保存训练过的模型 from sklearn.externals import joblib joblib.dump(clf, &quot;digits.pkl&quot;) #将训练的模型保存成digits.pkl文件 加载模型：clf = joblib.load(&quot;digits.pkl&quot;)其余操作数据即可，预测 3、鸢尾花分类（svm，分离出测试集）1234567891011121314151617181920from sklearn import datasetsfrom sklearn.cross_validation import train_test_splitfrom sklearn.svm import SVCimport numpy as np&apos;&apos;&apos;加载scikit-learn中的鸢尾花数据集&apos;&apos;&apos;#加载鸢尾花数据集iris = datasets.load_iris()iris_data = iris.data; #相当于Xiris_target = iris.target; #对应的label种类，相当于yx_train,x_test,y_train,y_test = train_test_split(iris_data,iris_target,test_size=0.2) #将数据分成训练集x_train和测试集x_test，测试集占总数据的0.2model = SVC().fit(x_train,y_train); #使用svm在训练集上拟合predict = model.predict(x_test) #在测试集上预测right = sum(predict == y_test) #求预测正确的个数print (&apos;测试集准确率：%f%%&apos;%(right*100.0/predict.shape[0])) #求在测试集上预测的正确率，shape[0]返回第一维的长度，即数据个数 [另：留一验证法]：–&gt;每次取一条数据作为测试集，其余作为训练集123456789101112131415161718192021222324from sklearn import datasetsfrom sklearn.svm import SVCimport numpy as npdef data_svc_test(data,target,index): x_train = np.vstack((data[0:index],data[index+1:-1]))#除第index号之外的 数据为训练集 x_test = data[index].reshape(1,-1) #第index号数据为测试集，reshape(1,-1)的作用是只有一条数据时，使用reshap e(1,-1)，否则有个过时方法的警告 y_train = np.hstack((target[0:index],target[index+1:-1])) y_test = target[index] model = SVC().fit(x_train,y_train) #建立SVC模型 predict = model.predict(x_test) return predict == y_test #返回结果是否预测正确#读取数据iris = datasets.load_iris()iris_data = iris.datairis_target = iris.targetm = iris_target.shape[0]right = 0;for i in range(0,m): right += data_svc_test(iris_data,iris_target,i)print (&quot;%f%%&quot;%(right*100.0/m)) 4、房价预测(SVR–&gt;支持向量回归)1234567891011121314151617181920212223from sklearn import datasetsfrom sklearn.svm import SVR #引入支持向量回归所需的SVR模型from sklearn.cross_validation import train_test_splitfrom sklearn.preprocessing import StandardScalerimport numpy as np#加载数据house_dataset = datasets.load_boston()house_data = house_dataset.datahouse_price = house_dataset.target#数据预处理--&gt;归一化x_train,x_test,y_train,y_test = train_test_split(house_data,house_price,test_size=0.2) scaler = StandardScaler()scaler.fit(x_train)x_train = scaler.transform(x_train) #训练集x_test = scaler.transform(x_test) #测试集#回归，预测model = SVR().fit(x_train,y_train) #使用SVR回归拟合predict = model.predict(x_test) #预测result = np.hstack((y_test.reshape(-1,1),predict.reshape(-1,1))) #reshape(-1,1)所有行转为1列向量print(result) 六、sk-learn模型总结0、数据处理（1）均值归一化：from sklearn.preprocessing import StandardScaler scaler = StandardScaler() scaler.fit(X_train) X_train = scaler.transform(X_train) （2）分割数据：from sklearn.cross_validation import train_test_split x_train,x_test,y_train,y_test = train_test_split(iris_data,iris_target,test_size=0.2) 1、线性模型from sklearn import linear_model（1）逻辑回归模型 linear_model.LogisticRegression() 重要参数 C：正则化作用，默认值1.0，值越小，正则化作用越强 max_iter：最大梯度下降执行次数，默认值100 tol：停止执行的容忍度，默认值1e-4 重要返回值 coef_：对应feature的系数 2、svm模型from sklearn import svm（1）分类模型 svm.SVC() 重要参数 kernel：使用的核函数，默认是rbf径向基函数，还有linear，poly，sigmoid ，precomputed核函数 C：正则化作用，默认值1.0，值越大，margin越大 tol：停止执行的容忍度，默认值1e-4 gamma：为核函数的系数，值越大拟合的越好，默认是1/feature的个数 degree：对应poly核函数 重要返回值","tags":[{"name":"Python","slug":"Python","permalink":"http://lawlite.me/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://lawlite.me/tags/机器学习/"}]},{"title":"搭建自己的VPN","date":"2016-11-05T09:33:50.000Z","path":"2016/11/05/搭建自己的VPN/","text":"一、首先租一个服务器 1、租一个香港的服务器，这里我选的按量付费，如果不使用了释放就可以了，按小时收费的，不过要求你账户上要多于100块钱。 2、操作系统选择的64位CentOS6.5，CentOS7以上下面的命令会有所不同。 3、创建成功后管理控制台会有公网和私网两个ip地址 二、配置VPN 1、安装ppp和pptpd: 1yum install ppp pptpd 2、配置DNS/etc/ppp/options.pptpd文件中的ms-dns配置为： 12ms-dns 8.8.8.8ms-dns 8.8.4.4 3、配置IP/etc/pptpd.conf文件中最后加入： 12localip 192.168.0.1remoteip 192.168.0.2-254 4、配置VPN用户名和密码/etc/ppp/chap-secrets文件中加入： 1userName pptpd password * 就是userName位置写上你的用户名，password位置写上你的密码 5、配置IP转发/etc/sysctl.conf文件中net.ipv4.ip_forward = 0改为1net.ipv4.ip_forward = 1 然后执行：sysctl -p使其生效 三、配置防火墙 1、加入防火墙规则 123iptables -A INPUT -p TCP -i eth1 --dport 1723 --sport 1024:65534 -j ACCEPTiptables -t nat -A POSTROUTING -o eth1 -s 192.168.0.0/24 -j MASQUERADEiptables -I FORWARD -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1356 注意这里指定的网卡是eth1，其对应外网的网卡，否则能够连上VPN，但是是访问不了外网的。 VPN默认的端口是1723 2、保存防火墙配置，启动pptpd，让其开机自启动 1234service iptables saveservice iptables restartservice pptpd start chkconfig pptpd on 四、测试1、window或手机等连接 对应外网IP，设置的用户名和密码 速度是可以的， 我也测试了一下国外的服务器，速度非常慢，还不如免费的VPN软件， 五、shell脚本 1、我写了一个简单的shell脚本放在了github上，github地址：https://github.com/lawlite19/Script 2、运行步骤如下： 下载脚本：wget https://raw.githubusercontent.com/lawlite19/Script/master/shell/vpn_setup.sh 添加执行权限：chmod +x vpn_setup.sh 执行即可：./vpn_setup.sh3、完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/bin/bash# Author: Wang Yongzhi(bob)# Date: 2016.11.16echo -e &quot;-----------------------------------------------&quot;echo -e &quot;| Setup VPN... |&quot;echo -e &quot;-----------------------------------------------\\n&quot;# Step 1:install ppp and pptpdyum install -y pppyum install -y pptpdif [ $? -eq 0 ]then echo -e &quot;install ppp and pptpd Success!\\n&quot;else echo -e &quot;Sorry! install ppp and pptpd Failed!\\n&quot; exit 0fi# Step 2:configure pptpd DNSsed -i -e &apos;/#ms-dns 10.0.0.1/a\\ms-dns 8.8.8.8&apos; /etc/ppp/options.pptpdsed -i -e &apos;/#ms-dns 10.0.0.2/a\\ms-dns 8.8.4.4&apos; /etc/ppp/options.pptpdif [ $? -eq 0 ]then echo -e &quot;Configure DNS Success!\\n&quot;else echo -e &quot;Configure DNS Failed!\\n&quot; exit 0fi# Step 3:configure pptpd IPecho localip 192.168.0.1 &gt;&gt; /etc/pptpd.confecho remoteip 192.168.0.2-254 &gt;&gt; /etc/pptpd.confif [ $? -eq 0 ]then echo -e &quot;Configure pptpd IP Success!\\n&quot;else echo -e &quot;Configure pptpd IP Failed!\\n&quot; exit 0fi# Step 4: configure VPN userName and passwordwhile truedo read -p &quot;Please input userName:&quot; userName read -p &quot;Please input passwd: &quot; Passwd echo $userName pptpd $Passwd \\* &gt;&gt; /etc/ppp/chap-secrets read -p &quot;continue?y/N: &quot; flag if [ $flag = &quot;n&quot; -o $flag = &quot;N&quot; ] then break fidone# Step 5: configure forwardingsed -i &apos;s/net.ipv4.ip_forward = 0/net.ipv4.ip_forward = 1/g&apos; /etc/sysctl.confif [ $? -eq 0 ]then echo -e &quot;Configure forwarding Success!\\n&quot;else echo -e &quot;Configure forwarding Failed\\n&quot; exit 0fisysctl -p# Step 6: configure iptables#EXTIF=$(ifconfig | head -n 1 | grep -v lo | cut -d &apos; &apos; -f 1)iptables -A INPUT -p TCP -i eth1 --dport 1723 --sport 1024:65534 -j ACCEPTiptables -t nat -A POSTROUTING -o eth1 -s 192.168.0.0/24 -j MASQUERADEiptables -I FORWARD -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1356# Step 7: configure when start server to start pptpd and iptablesservice iptables saveservice iptables restartservice pptpd start chkconfig pptpd onecho -e &quot;Complete! Now you can connect the VPN throuth your computer or phone!\\n&quot;echo &quot; ***** *****&quot;echo &quot; ********* *********&quot;echo &quot; ************* *************&quot;echo &quot; *****************************&quot;echo &quot; *****************************&quot;echo &quot; *****************************&quot;echo &quot; ***************************&quot;echo &quot; ***********************&quot;echo &quot; *******************&quot;echo &quot; ***************&quot;echo &quot; ***********&quot;echo &quot; *******&quot;echo &quot; ***&quot;echo &quot; *&quot; 六、总结 最初是在租了一个国外的服务器测试的，没有问题，但是后来租用香港的服务器就出现的了错误，同样的系统、同样的配置，后来查看内网绑定的是网卡eth0,外网绑定的是网卡eth1，而我防火墙里设置的是内网的网卡eth0。而国外的那个服务器只要一个网卡，所以没有问题。另外练练shell脚本。","tags":[{"name":"翻墙","slug":"翻墙","permalink":"http://lawlite.me/tags/翻墙/"}]},{"title":"Scrapy爬虫框架模板","date":"2016-10-09T05:42:56.000Z","path":"2016/10/09/Python爬虫-Scrapy/","text":"说明 github地址：https://github.com/lawlite19/PythonCrawler-Scrapy-Mysql-File-Template 使用scrapy爬虫框架将数据保存Mysql数据库和文件中 settings.py 修改Mysql的配置信息 1234567#Mysql数据库的配置信息MYSQL_HOST = '127.0.0.1'MYSQL_DBNAME = 'testdb' #数据库名字，请修改MYSQL_USER = 'root' #数据库账号，请修改 MYSQL_PASSWD = '123456' #数据库密码，请修改MYSQL_PORT = 3306 #数据库端口，在dbhelper中使用 指定pipelines 1234ITEM_PIPELINES = &#123; 'webCrawler_scrapy.pipelines.WebcrawlerScrapyPipeline': 300,#保存到mysql数据库 'webCrawler_scrapy.pipelines.JsonWithEncodingPipeline': 300,#保存到文件中&#125; items.py 声明需要格式化处理的字段 123456class WebcrawlerScrapyItem(scrapy.Item): '''定义需要格式化的内容（或是需要保存到数据库的字段）''' # define the fields for your item here like: # name = scrapy.Field() name = scrapy.Field() #修改你所需要的字段 url = scrapy.Field() pipelines.py一、保存到数据库的类WebcrawlerScrapyPipeline（在settings中声明） 定义一个类方法from_settings，得到settings中的Mysql数据库配置信息，得到数据库连接池dbpool 12345678910111213141516@classmethoddef from_settings(cls,settings): '''1、@classmethod声明一个类方法，而对于平常我们见到的则叫做实例方法。 2、类方法的第一个参数cls（class的缩写，指这个类本身），而实例方法的第一个参数是self，表示该类的一个实例 3、可以通过类来调用，就像C.f()，相当于java中的静态方法''' dbparams=dict( host=settings['MYSQL_HOST'],#读取settings中的配置 db=settings['MYSQL_DBNAME'], user=settings['MYSQL_USER'], passwd=settings['MYSQL_PASSWD'], charset='utf8',#编码要加上，否则可能出现中文乱码问题 cursorclass=MySQLdb.cursors.DictCursor, use_unicode=False, ) dbpool=adbapi.ConnectionPool('MySQLdb',**dbparams)#**表示将字典扩展为关键字参数,相当于host=xxx,db=yyy.... return cls(dbpool)#相当于dbpool付给了这个类，self中可以得到 __init__中会得到连接池dbpool 12def __init__(self,dbpool): self.dbpool=dbpool process_item方法是pipeline默认调用的，进行数据库操作 12345#pipeline默认调用def process_item(self, item, spider): query=self.dbpool.runInteraction(self._conditional_insert,item)#调用插入的方法 query.addErrback(self._handle_error,item,spider)#调用异常处理方法 return item 插入数据库方法_conditional_insert 123456#写入数据库中def _conditional_insert(self,tx,item): #print item['name'] sql=\"insert into testpictures(name,url) values(%s,%s)\" params=(item[\"name\"],item[\"url\"]) tx.execute(sql,params) 错误处理方法_handle_error 123#错误处理方法def _handle_error(self, failue, item, spider): print failue 二、保存到文件中的类JsonWithEncodingPipeline（在settings中声明） 保存为json格式的文件，比较简单，代码如下 123456789101112class JsonWithEncodingPipeline(object): '''保存到文件中对应的class 1、在settings.py文件中配置 2、在自己实现的爬虫类中yield item,会自动执行''' def __init__(self): self.file = codecs.open('info.json', 'w', encoding='utf-8')#保存为json文件 def process_item(self, item, spider): line = json.dumps(dict(item)) + \"\\n\"#转为json的 self.file.write(line)#写入文件中 return item def spider_closed(self, spider):#爬虫结束时关闭文件 self.file.close() dbhelper.py 自己实现的操作Mysql数据库的类 init方法，获取settings配置文件中的信息 12345678def __init__(self): self.settings=get_project_settings() #获取settings配置，设置需要的信息 self.host=self.settings['MYSQL_HOST'] self.port=self.settings['MYSQL_PORT'] self.user=self.settings['MYSQL_USER'] self.passwd=self.settings['MYSQL_PASSWD'] self.db=self.settings['MYSQL_DBNAME'] 连接到Mysql 123456789#连接到mysql，不是连接到具体的数据库def connectMysql(self): conn=MySQLdb.connect(host=self.host, port=self.port, user=self.user, passwd=self.passwd, #db=self.db,不指定数据库名 charset='utf8') #要指定编码，否则中文可能乱码 return conn 连接到settings配置文件中的数据库名（MYSQL_DBNAME） 123456789#连接到具体的数据库（settings中设置的MYSQL_DBNAME）def connectDatabase(self): conn=MySQLdb.connect(host=self.host, port=self.port, user=self.user, passwd=self.passwd, db=self.db, charset='utf8') #要指定编码，否则中文可能乱码 return conn 创建数据库（settings文件中配置的数据库名） 12345678910#创建数据库def createDatabase(self): '''因为创建数据库直接修改settings中的配置MYSQL_DBNAME即可，所以就不要传sql语句了''' conn=self.connectMysql()#连接数据库 sql=\"create database if not exists \"+self.db cur=conn.cursor() cur.execute(sql)#执行sql语句 cur.close() conn.close() 还有一些数据库操作方法传入sql语句和参数即可（具体看代码） 实现具体的爬虫.py（即模板中的pictureSpider_demo.py文件） 继承scrapy.spiders.Spider 类 声明三个属性 12345name=\"webCrawler_scrapy\" #定义爬虫名，要和settings中的BOT_NAME属性对应的值一致allowed_domains=[\"desk.zol.com.cn\"] #搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页start_urls=[\"http://desk.zol.com.cn/fengjing/1920x1080/1.html\"] #开始爬取的地址 实现parse方法，该函数名不能改变，因为Scrapy源码中默认callback函数的函数名就是parse 1def parse(self, response): 返回item 123456item=WebcrawlerScrapyItem() #实例item（具体定义的item类）,将要保存的值放到事先声明的item属性中item['name']=file_name item['url']=realUrlprint item[\"name\"],item[\"url\"] yield item #返回item,这时会自定解析item 测试 测试DBHelper创建testdb数据库和testtable表 测试爬虫 在D盘建立文件夹pics; 图片自动保存到该文件夹中。 scrapy crawl webCrawler_scrapy运行爬虫后会将爬取得图片保存到本地，并且将name和url保存到数据库中","tags":[{"name":"Python","slug":"Python","permalink":"http://lawlite.me/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://lawlite.me/tags/爬虫/"}]},{"title":"算法练习","date":"2016-09-09T05:35:45.000Z","path":"2016/09/09/算法练习/","text":"说明 github地址：https://github.com/lawlite19/AlgorithmExercises一、 排序算法1. 交换排序 冒泡排序 冒泡排序改进1 冒泡排序改进2 冒泡排序改进3 快速排序 2. 插入排序 直接插入排序 直接插入排序递归版 希尔排序 3. 选择排序 简单选择排序 二元选择排序 堆排序 4. 归并排序 二路归并排序递归版 二路归并排序非递归版 二、 字符串1. 字符串旋转 字符串旋转_暴力法 字符串旋转_三步翻转法 2. 字符串包含 字符串包含判断_遍历 字符串包含判断_排序 字符串包含判断_素数乘积 字符串包含判断_哈希 ★★★ 3. 回文 回文判断 4. 最长回文子串长度 最长回文子串长度_一般解法 最长回文子串长度_Manacher ★★★ 算法说明 5. 全排列 全排列_递归 全排列_字典序排列 字典序全排列 6. 变形词 变形词判断 7. 字符串中数字串之和 字符串中数字串之和 ★ 8. 去除字符串中连续K个0串 去除字符串中连续K个0串 9. 整数字符串转整数值 整数字符串转整数值 ★★ 10. 字符串匹配问题 字符串匹配_KMP ★★★★★ 算法说明 三、 数组和矩阵1. 二维数组查找 二维数组查找 2. 矩阵相关操作 转圈打印矩阵 3. 最小的k个元素 最小的k个元素_堆 最小的k个元素_BFPRT ★★★★★ 算法说明 4.中间数 中间数_辅助数组 ★ 5.非负数组和为K的最长子数组 非负数组和为K的最长子数组_双指针 ★★★ 8.次数出现大于N/K的数 次数出现大于N/2的数 ★ 次数出现大于N/K的数 ★★★ 9.逆序对 逆序对数_分治归并★ 10.两个有序数组的中位数 两个有序数组的中位数_分治★★★★ 算法说明 四、 递归和动态规划1. 斐波那契问题 矩形覆盖_递归 矩形覆盖_dp ★ 矩阵覆盖_矩阵转化_class实现 ★★★ 矩阵覆盖_矩阵转化_vector实现 ★★★ 算法说明 爬楼梯_递归 爬楼梯_dp ★ 变态跳台阶_递归 变态跳台阶_直接计算 ★ 2. 最大子数组和相关问题 最大子数组和_dp ★ 两个不相容子数组最大和_辅助数组 ★★ 3. 最长递增子序列相关问题 最长递增子序列_一般dp 最长递增子序列_dp优化 ★★ 摞数组问题(俄国沙皇问题)_纯代码实现 ★★★★ 摞数组问题（俄国沙皇问题）_借助stl ★★★★ 五、 栈和队列1. getMin功能栈 getMin功能栈_方案1 getMin功能栈_方案2 2. 两个栈实现队列功能 两个栈实现队列 七、二叉树1. 遍历 先、中、后序遍历_递归 先、中、后序遍历_非递归 ★★ 八、位运算 出现奇数次的数","tags":[{"name":"算法","slug":"算法","permalink":"http://lawlite.me/tags/算法/"}]}]